---
title: Fundamentos da Linguagem Go
sidebar_position: 1
slug: /fundamentos-go
---


## 1. Algumas definiÃ§Ãµes importantes

- Pode ser utilizado para estudar com o playground: https://go.dev/play/
- Link para documentaÃ§Ã£o: https://go.dev/doc/effective_go
- Go foi criado com os trÃªs pilares: *efficient compilation, efficient execution and ease of programming*.

---

## 2. Primeiro programa em Go

```go
// Line comments - Hello World from GoLang
package main

import "fmt"

func main() {
	fmt.Println("Hello, Mundo!")
}
/*Bloco de comentÃ¡rios!
Aqui vÃ¡rias linhas */
```

Quando compartilhando cÃ³digo para foruns, Ã© interessante enviar o cÃ³digo da pergunta utilizando, por exemplo, o PlayGround. Ele permite que as pessoas editem e enviem sugestÃµes de modificaÃ§Ãµes para os autores.

Os programas para serem executados, eles devem possuir um pacote main. Dentro deste pacote `main`, Ã© necessÃ¡rio uma funÃ§Ã£o `main`, ela Ã© o ponto de entrada do nosso projeto.

Todos os cÃ³digos de Go sÃ£o organizados em pacotes. Ã‰ a forma como nossos projetos ficam distribuÃ­dos e organizados. O pacote `fmt` Ã© da biblioteca padrÃ£o do Go, ele permite utilizar as funÃ§Ãµes de entrada e saÃ­da, por exemplo.

```go
package main

import "fmt"

func main() {
	const nome = "Murilo Zanini"
	const idade = 36
	const peso = 108.5
	fmt.Println("Ola Mundo da FormataÃ§Ã£o!")
	fmt.Printf("Aqui vai uma string: %s\n", nome)
	fmt.Printf("Aqui vai um nÃºmero inteiro: %d\n", idade)
	// Ultima linha de cÃ³digo da funÃ§Ã£o nÃ£o precisa do ;
	fmt.Printf("Aqui vai um nÃºmero real: %.3f\n", peso)
}
```

Para ver mais detalhes de formataÃ§Ã£o: https://pkg.go.dev/fmt#Printf

A codificaÃ§Ã£o UTF-8 Ã© uma forma de armazenar os dados UNICODE dos caracteres de forma eficiente. Go utiliza UTF-8 e UNICODE para armazenar os dados. Para saber mais: 
- https://developer.mozilla.org/pt-BR/docs/Glossary/UTF-8
- https://www.ime.usp.br/~pf/algoritmos/apend/unicode.html
- https://www.w3schools.com/charsets/ref_html_utf8.asp

---

Go Ã© uma linguagem estÃ¡ticamente tipada. Isso significa que os tipos sÃ£o definidos no momento da compilaÃ§Ã£o do nosso programa e nÃ£o em sua execuÃ§Ã£o. As variÃ¡veis para serem utilizadas precisam ser declaradas. Nesse ponto, a atribuiÃ§Ã£o pode ser realizada de algumas formas:

1. AtribuiÃ§Ã£o com inicializaÃ§Ã£o, nÃ£o precisa definir o tipo da variÃ¡vel, ele Ã© inferido de forma automÃ¡tica: `nome := "Murilo"`
2. ATENÃ‡ÃƒO: VariÃ¡veis e constantes sÃ£o inicializadas de forma distinta em Go.
3. Para declarar uma variÃ¡vel e nÃ£o atribuir um valor inicial para ela, Ã© necessÃ¡rio utilizar o inicializador com valor zero: `var idade int`. Desta forma, a variÃ¡vel estÃ¡ inicializada com um valor inicial.
4. Quando um valor Ã© atribuÃ­do a uma variÃ¡vel e ela nÃ£o Ã© utilizada, o cÃ³digo lanÃ§a um erro quando ele tenta ser executado.

```go
package main

import "fmt"

func main() {
	// O ponto e virgula no final da expressa Ã© opcional
	idade := 36
	fmt.Printf("Valor da idade: %d\n", idade)
	var nome string
	fmt.Printf("Nome informado: %s\n", nome)
	// ATENÃ‡ÃƒO: Strings utilizam ", chars Ãºnicos utilizam '
	nome = "Murilo"
	fmt.Printf("Nome depois da atribuiÃ§Ã£o: %s\n", nome)
	// Multiplo inicializador e operador _
	a, b, _, d := 1, 2, 3, 4
	fmt.Printf("Valores informados: %d %d %d", a, b, d)
	// O operador _ Ã© utilizado quando um valor de retorno Ã© 
	// fornecido e ele nÃ£o serÃ¡ utilizado no contexto.
}
```

O nulo do Golang Ã© `nil`.

Para apresentaÃ§Ã£o de valores em binÃ¡rio e hexadecimal:

```go
package main

import "fmt"

func main() {
	valor1, valor2 := 'a', 15
	fmt.Printf("Valor em binÃ¡rio: %b\n", valor1)
	fmt.Printf("Valor em hexadecimal: %x", valor2)

}
```

Para iniciar um valor alÃ©m do zero inicial: `var a int = 42`. Para realizar o cast de tipo, utilizar: 

```go
package main

import "fmt"

func main() {
	var variavel1 int = 42
	variavel2 := float32(variavel1)
	fmt.Printf("Valor em inteiro: %d\n", variavel1)
	fmt.Printf("Valor em float: %f\n", variavel2)

	// Exibindo o tipo
	fmt.Printf("Tipo da variavel 1: %T\n", variavel1)
	fmt.Printf("Tipo da variavel 2: %T\n", variavel2)

}
```

Para utilizar mais de um pacote, utilizamos o `()` para descrever todos os pacotes que estamos importando.

```go
package main

// Doc da lib "math/rand" - https://pkg.go.dev/math/rand

import (
	"fmt"
	"math/rand"
)

func main() {
	fmt.Printf("Valor aleatÃ³rio ðŸŽ²: %d\n", rand.Intn(6))
}
```

IMPORTANTE: quando queremos que algo fique disponÃ­vel fora do pacote que ele foi criado, utilizar letra maiÃºscula para descrever ela. Por exemplo, o valor `MeuValor`, fica disponÃ­vel quando o pacote for importado, ela serÃ¡ exportada. Quando utilizamos o identificador `meuValor`, ele pode ser utilizado apenas dentro do pacote, ele nÃ£o serÃ¡ exportado. Valor para funÃ§Ãµes. Ã‰ equivalente ao conceito de pÃºblico/privado de linguagens orientadas a objeto.

```go
package main

import (
	"fmt"
)

// FunÃ§Ã£o nÃ£o Ã© exportada no pacote
func encontraMaior(x, y int) int {
	if x > y {
		return x
	}
	return y
}

// Ã‰ possÃ­vel retornar mais de um valor com uma funÃ§Ã£o
func trocados(valor1 int, valor2 int, valor3 float32) (float32, int, int) {
	return valor3, valor2, valor1
}

func main() {
	x, y, z := trocados(10, 3, 4.)
	fmt.Printf("Chamda da funÃ§Ã£o: %f\t%d\t%d\n", x, y, z)
}
```

Go suporte operaÃ§Ãµes do tipo bitwise e bitshift. Para verificar mais sobre o que pode ser realizado com Go em nÃ­vel de bit manipulation: https://pkg.go.dev/math/bits#pkg-overview.

Go possui um operador para trazer identificadores que sÃ£o construÃ­dos com um incremento. Esse elemento Ã© o `iota`. A documentaÃ§Ã£o pode ser vista em: https://go.dev/wiki/Iota.

```go
package main

import (
	"fmt"
)

// Criando uma enumeraÃ§Ã£o
type WeekDay int

const (
	domingo WeekDay = iota //Fica valendo 0
	segunda
	terca
	quarta
	quinta
	sexta
	sabado
)

func main() {
	fmt.Printf("Utilizando valores do enum: %d\t%d\n", domingo, sabado)
}
```

Para executar um programa em Go:

```bash
go run ./nome_arquivo.go
```

Para desenvolver os programas em Go utilizando o ambiente de desenvolvimento nativo, vamos precisar de algumas ferramentas:
- O compilador/runtime de Go
- Git instalado na mÃ¡quina
- Um editor (no momento, o VS Code)
- DependÃªncias de desenvolvimento (plugins do Go com VS Code)

Com a extensÃ£o de Go instalada no VS Code, utilizar o comando: `go install` para instalar as ferramentas e dependÃªncias de cÃ³digo. Selecionar todas e instalar. Todas as ferramentas sÃ£o instaladas dentro do caminho indicado em $GOPATH.

Os mÃ³dulos em GoLang sÃ£o utilizados para realizar o `namespacing` das dependÃªncias do cÃ³digo. Desta forma Ã© possÃ­vel importar os mÃ³dulos e realizar seu gerenciamento sem maiores problemas de conflito. Para iniciarmos um mÃ³dulo, dentro do diretÃ³rio da nossa soluÃ§Ã£o, utilizar o comando: `go mod init nome/modulo`.

Ã‰ possÃ­vel compilar o programa para outras plataformas diferentes da de desenvolvimento utilizando Go. Verificar a documentaÃ§Ã£o: https://go.dev/doc/tutorial/compile-install

O `mod` do Go Ã© equivalente ao `pip` do Python. Para instalar as dependÃªncias listadas em um arquivo `mod` de um projeto, podemos utilizar o comando: `go mod tidy`. Mais sobre ele na documentaÃ§Ã£o: https://go.dev/ref/mod .

Em GoLang, utilizamos o conceito de exportado ou nÃ£o exportado para descrever o que estÃ¡ dentro do mÃ³dulo/pacote ou apenas dentro dele.

Para importar um arquivo que estÃ¡ dentro do mÃ³dulo, precisamos informar o caminho dele. Para isso, ele deve ter sua rota iniciada dentro do nome do pacote fornecido no comando de criar o pacote com o `go mod`.

Para um projeto com diversos diretÃ³rios, temos dentro do arquivo `puppy.go`:

```go 
package puppy

// FunÃ§Ãµes do pacote
func Bark() string{
	return "Au!"
}

func Barks() string{
	return "Ufufufufu!"
}
```

Agora dentro arquivo `main.go`:

```go
package main

import (
	"fmt"
	"modulos_projeto01/puppy"
)

func main() {
	fmt.Printf("%s\n", puppy.Bark())
	fmt.Printf("%s\n", puppy.Barks())
}
```

O que estiver no pacote `main` nÃ£o precisa estar em um diretÃ³rio separado para sua execuÃ§Ã£o. Para fazer um pacote utilizar dependÃªncias dos demais, editar o arquivo `go.mod`, para que ele possa ver os pacotes:

```go
module modulos_projeto01

go 1.23.2
```

Dentro do `dog/funcoes.go`:

```go
package dog

import (
	"strings"
)

func BigDog(msg string) (string){
	return strings.ToUpper(msg)
}
```

Dentro do `puppy/puppy.go`:

```go
package puppy

import (
	"modulos_projeto01/dog"
)

// FunÃ§Ãµes do pacote
func Bark() string{
	return "Au!"
}

func Barks() string{
	return "Ufufufufu!"
}

func BigBark() string{
	return dog.BigDog(Bark())
}
```

E por fim, dentro da `main.go`:

```go
package main

import (
	"fmt"
	"modulos_projeto01/puppy"
)

func main() {
	fmt.Printf("%s\n", puppy.Bark())
	fmt.Printf("%s\n", puppy.Barks())
	fmt.Printf("%s\n", puppy.BigBark())
}
```

---

## 3. Estruturas de controle em Go

Retomando: os programas em Go sÃ£o iniciados no pacote `main`, pela funÃ§Ã£o `main`.

Estrutura de decisÃ£o `if` similar a do C, Java. O bloco de cÃ³digo do `if`, deve estar entre `{}`. A condiÃ§Ã£o de verificaÃ§Ã£o nÃ£o precisa estar entre `()`. Podemos encadear as estruturas de decisÃ£o utilizando `else if`. Os operadores lÃ³gicos sÃ£o os mesmos de C e Java.

A estrutura `switch` pode ser utilizada de algumas maneiras distintas:

```go
package main

import "fmt"

func main() {
	x := 10

	// Exemplo de utilizaÃ§Ã£o de switch
	// Caso 1
	switch {
	case x > 5:
		{
			fmt.Printf("Valor maior que 5\n")
		}
	case x < 5:
		{
			fmt.Printf("Aqui vai mais um!\n")
		}
	default:
		{
			fmt.Printf("Valor padrÃ£o\n")
		}
	}

	// Caso 2
	switch x {
	case 1:
		{
			fmt.Printf("O que fazer com o valor 1\n")
		}
	case 2:
		{
			fmt.Printf("Aqui para o 2\n")
		}
	}
}

```

Existe um operador chamado de `select`, ele funciona de forma similar ao `switch`, mas para o contexto de paralelismo e comunicaÃ§Ã£o entre canais. Mais sobre o tema logo menos.

O loop `for` pode ser utilizado de algumas formas distintas:

```go
package main

import "fmt"

func main(){
	// Primeiro exemplo de utilizaÃ§Ã£o de for
	for x:= 0; x < 10; x++{
		fmt.Printf("Primeiro Exemplo do For - %d\n", x)
	}

	// Segundo exemplo de utilizaÃ§Ã£o de for
	x := 0
	for x < 10 {
		fmt.Printf("Segundo Exemplo do For - %d\n", x)
		x++
	}

	// Terceiro exemplo de utilizaÃ§Ã£o do for
	x = 0
	for{
		fmt.Printf("Terceiro Exemplo do For - %d\n", x)
		x++
		if x == 10 {
			break
		}
	}
}
```

Ã‰ possÃ­vel realizar interaÃ§Ãµes uma dentro da outra (loops internos). Existe uma outra variaÃ§Ã£o do for que permite utilizar ele para varrer um conjunto de valores dentro de um slice (similar a uma lista). TambÃ©m pode ser utilizado com um mapa.

```go
package main

import "fmt"

func main(){
	// Criando um slice
	x := [] int{42, 34, 56, 78, 90, 12}

	// Utilizando um for para interar por todos os valores
	for i, valor := range x{
		fmt.Printf("Valor na posiÃ§Ã£o %d \t %d\n", i, valor)
	}

	// Utilizando a mesma lÃ³gica para navegar em mapas
	y := map[string]int{
		"Murilo":36,
		"Goku":42, "Vegeta":44,
	}

	for chave, valor := range y{
		fmt.Printf("Valor declarado como chave: %s\t e o conteÃºdo: %d\n", chave, valor)
	}
}
```

---

Em muitas situaÃ§Ãµes, Ã© conveniente utilizar alguns tipos de dados que permitem trabalhar com diversos valores agregados. A linguagem Go traz alguns tipos agregados que permitem realizar esse tipo de manipulaÃ§Ã£o. Essas estruturas sÃ£o chamadas de `aggregate data types`.


Os tipos de dados agregados em Go sÃ£o:

- `array`: sequencia do mesmo tipo de dados. NÃ£o muda de tamanho. Em geral, utilizado nas implementaÃ§Ãµes internas de Go.
- `slice`: construÃ­do sobre as caracterÃ­sticas de um array, portanto sÃ³ podem armazenar valores do mesmo tipo. Podem mudar seu tamanho. Possuem um comprimento e uma capacidade.
- `map`: armazenam um conjunto de chaves e valores, cada um de um tipo respectivo. Os valores nÃ£o sÃ£o armazenados de forma sequencia ou ordenada.
- `struct`: tipo composto de dados que permite representar um conjunto de diferentes variÃ¡veis.

## 4. Arrays

Exemplo de utilizaÃ§Ã£o de arrays:

```go
package main

import "fmt"

func main(){
	// Declara um array e realiza algumas manipulaÃ§Ãµes com ele
	// Determinamos o nome do array, seu tamanho e seu tipo
	var meuArray [10]int

	// Imprime o array
	fmt.Printf("%#v\t Tipo do arrat: %T\n", meuArray, meuArray)

	// Para imprimir o array de forma nÃ£o estruturada
	fmt.Printf("%v\n", meuArray)

	// Atribuindo um valor para o array
	meuArray[0] = 10
	meuArray[1] = meuArray[0]/3

	// Imprimi o array novamente
	fmt.Printf("%v\n", meuArray)

	// Declara e inicializa o array
	// PosiÃ§Ãµes nÃ£o iniciadas, tem seu valores zerado/nulo atribuÃ­do a elas.
	nomes := [5]string{"Murilo", "Goku", "Vegeta",}

	// Declara o array e deixa o Go inferir a quantidade de memÃ³ria necessÃ¡ria
	idades := [...]int{36,29,9}

	// Imprime o array
	fmt.Printf("%#v\t Tipo do array: %T\n", nomes, nomes)
	fmt.Printf("%#v\t Tipo do array: %T\n", idades, idades)

	// Utiliza o tamanho do array
	fmt.Printf("Tamanho do array: %d\n", len(idades))
}
```

## 5. Slices

Slices sÃ£o como arrays, mas eles podem ter seu tamanho alterado dinamicamente. Portanto mais elemento podem ser adicionados a ele. Os slices podem ser utilizados em conjunto com a funÃ§Ã£o range tambÃ©m. Alguns detalhes de implementaÃ§Ã£o dos slices:

```go
package main

import (
	"fmt"
	"strconv" //Para os casts de tipo
)

// GOlang nÃ£o suporta overloading de funÃ§Ãµes
func MostrarSliceString(lista []string){
	fmt.Printf("ConteÃºdo atual do Slice: %v\n", lista)
}


func MostrarSliceInt(lista []int){
	fmt.Printf("ConteÃºdo atual do Slice: %v\n", lista)
}


func main(){

	// Criando um slice
	// Aqui o slice Ã© instÃ¢nciado mas nÃ£o tem nenhum valor atribuÃ­do a ele
	meu_slice := []string{}	

	MostrarSliceString(meu_slice)

	// Adicionando elementos ao slice
	// Importante notar aqui: O append adiciona um novo elemento no slice, mas ele precisa realizar a reatribuiÃ§Ã£o, que o retorno da funÃ§Ã£o, caso contrÃ¡rio, ele nÃ£o modifica o slice enviado para ele.
	_ = append(meu_slice, "entra aqui!")

	MostrarSliceString(meu_slice)

	// Com a reatribuiÃ§Ã£o
	meu_slice = append(meu_slice, "Agora sim entra aqui")

	MostrarSliceString(meu_slice)

	// Instanciando e inicializando um slice
	novo_slice := []int{4, 5, 9, -78}

	// Converter um inteiro para string e appenda no slice
	meu_slice = append(meu_slice, strconv.Itoa(novo_slice[0]))

	MostrarSliceInt(novo_slice)
	MostrarSliceString(meu_slice)


	// Utilizando o for-range
	for indice, valor := range novo_slice{
		fmt.Printf("%d valor na posiÃ§Ã£o %d\n", indice, valor)
	}
}
```


Ao tentar acessar um posiÃ§Ã£o que nÃ£o estÃ¡ dentro do range de um slice, um erro vai ser lanÃ§ado. Partes de um slice podem ser acessadas utilizando os indices, como as listas em Python.

```go
package main

import "fmt"

func imprimir(v []int) {
	fmt.Printf("%v\n", v)
}

func algumaCoisa() {
	meu_slice := []int{4, 5, 8, 9}
	parte_1 := meu_slice[0:2] //4,5
	parte_2 := meu_slice[:3]  //4,5,8
	parte_3 := meu_slice[2:]  //8,9
	imprimir(meu_slice)
	imprimir(parte_1)
	imprimir(parte_2)
	imprimir(parte_3)
}

func main() {
	fmt.Println("Hello, ä¸–ç•Œ")
	algumaCoisa()
}
```


Importante, para remover um elemento do slice, fazemos uma cÃ³pia sem ele.

```go
func RemoveIndex(s []int, index int) []int {
    return append(s[:index], s[index+1:]...)
}
```

Utilizando a funÃ§Ã£o `make()`, Ã© possÃ­vel reservar memÃ³ria para utilizar os elementos de um slice que serÃ£o conhecidos (espaÃ§o de memÃ³ria que serÃ¡ utilizado). Esse espaÃ§o fica reservado, mas nÃ£o altera o tamanho atual do slice.

```go
// Pacote e cÃ³digo anterios

func verificandoSlice(lista []string){
	fmt.Printf("Elemento recebido: %v\t Size: %d Capacidade: %d\n", lista, len(lista), cap(lista))
}

func utilizandoMake(){
	// Utilizando o make para alocar memÃ³ria para um slice
	// O slice Ã© iniciado com 0 elementos e reservando 10 posiÃ§Ãµes de memÃ³ria
	nomes := make([]string, 0, 10)	
	verificandoSlice(nomes)
	nomes = append(nomes, "Murilo")
	nomes = append(nomes, "Vegeta")
	verificandoSlice(nomes)
	nomes = append(nomes, "Goku")
	verificandoSlice(nomes)
}

func main(){
	utilizandoMake()	
}
```

Ã‰ possÃ­vel utilizar um slice de slices em Go. Ã‰ como utilizar uma matriz de elementos.

```go
func trabalhandoComSliceDeSlice(){
	gigante := [][]int{}
	gigante = append(gigante, []int{1,2,3})
	// Podem ser de tamanhos distintos
	gigante = append(gigante, []int{4,5,})
	fmt.Println(gigante)
	fmt.Println("Exibindo apenas uma posiÃ§Ã£o:", gigante[0][1])
	fmt.Println("Exibindo nÃºmero de linhas (quantos slices dentro):", len(gigante))
}

func main(){
	trabalhandoComSliceDeSlice()	
}
```

Arrays, slices e outras estruturas em Go sÃ£o enviados por valor. Para passar eles por referÃªncia, Ã© necessÃ¡rio enviar eles utilizando um ponteiro.

## 6. Maps

Os mapas sÃ£o uma forma de construir estruturas do tipo chave-valor, com os mesmos tipos de dados em cada elemento da estrutura. Sua sintaxe Ã© `variavel := map[tipo_chave] tipo_valor{ chave:valor, chave2:valor2}`. Alguns exemplos de manipulaÃ§Ã£o de dicionÃ¡rios.

```go
package main

import (
	"fmt"
)

func Funcionalidade_01(){
	// Cria o literal de um mapa
	idades := map[string]int{
		"Murilo":36,
		"Vegeta":44,
		"Goku":42,
	}

	// Exibe todo o mapa
	fmt.Println(idades)

	// Altera o valor da idade de uma chave
	idades["Goku"] = 10
	fmt.Println(idades)

	// Inserindo valores nos mapas
	idades["Bulma"] = 35
	fmt.Println(idades)

	// Acessando todos os elementos dentro do mapa
	for chave, valor := range(idades){
		string_saida := fmt.Sprintf("Valor %d com chave %s", valor, chave)
		fmt.Println(string_saida)
	}

	// Testando se existe uma chave. Se o valor nÃ£o for utilizado, um _ pode ser utilizado.
	valor, ok := idades["Blonko"]	//Verifica se a chave existe
	if ok{
		fmt.Println("Valor da chave:", valor)
	} else {
		fmt.Println("Essa chave nÃ£o existe")
	}

	// Para deletar uma chave
	// No caso de uma deleÃ§Ã£o de chave que nÃ£o existe, nada Ã© alterado no mapa.
	delete(idades, "Teste")

}

func main(){
	Funcionalidade_01()
}
```

Verificar essa implementaÃ§Ã£o:

```go
package main

import (
	"fmt"
)

func Funcionalidade_02(){
	// Criando um mapa para listas
	comidas := map[string] []string{
		"Murilo" : {"Lamen", "MacarrÃ£o", "Pizza",},
		"Vegeta" : {"Hambuguer", "Doces"},
		"Goku" : {"Lamen", "Hambuguer", "Hotdog",},
	}

	// Passando pelos elementos do mapa
	for chave, _ := range(comidas){
		fmt.Printf("%s gosta de: ", chave)
		for _, dado := range(comidas[chave]) {
			fmt.Printf("%s\t", dado)
		}
		fmt.Println()
	}
}

func main(){
	Funcionalidade_02()
}
```


## 7. Structs

Utilizando estruturas do tipo `Struct`, podemos colocar valores de tipos distintos no mesmo tipo abstrato de dado. As estruturas sÃ£o muito semelhantes aos structs da linguagem C. Os elementos da struct podem ser acessados como os itens das estruturas em C, utilizando o operador ponto.

```go
package main

import "fmt"

// DeclaraÃ§Ã£o das estruturas que sÃ£o utilizadas no programa
type person struct{
	primeiroNome string
	sobreNome string
	idade int
}

// A estrutura pode ser instÃ¢nciada como uma variÃ¡vel

func TesteFuncionalidade01(){
	p1 := person{
		primeiroNome: "Murilo",
		sobreNome: "Carvalho",
		idade: 36,
	}

	p2 := person{"Kakaroto", "Goku", 42}

	p3 := person{
		idade: 44,
		primeiroNome: "Vegeta",
		sobreNome: "Prince",
	}

	// Exibe as trÃªs pessoas
	fmt.Println(p1)
	fmt.Println(p2)
	fmt.Println(p3)

	// Acessa um elemento da struct
	fmt.Println("Nome de p1:", p1.primeiroNome)
}

func main(){
	TesteFuncionalidade01()
}
```


Structs podem ser utilizados dentro de outros structs (struct embedding). Neste caso, colocar os construtores (inicializadores) dentro da construÃ§Ã£o da estrutura mais externa (quando for necessÃ¡rio).

```go
package main

import "fmt"

// DeclaraÃ§Ã£o das estruturas que sÃ£o utilizadas no programa
type person struct{
	primeiroNome string
	sobreNome string
	idade int
}


// Criando mais uma estrutura
type professor struct{
	pessoa person
	especialidade string
}

func TesteFuncionalidade02(){
	// Criando uma estrutura que possui outra estrutura dentro dela
	p1 := professor{
		pessoa: person{
			primeiroNome: "Murilo",
			sobreNome: "Carvalho",
			// Valores nÃ£o inicializados, tem o valor 0 ou nil atribuÃ­dos a eles.
		},
		especialidade: "ComputaÃ§Ã£o",
	}

	fmt.Println(p1)
}

func main(){
	TesteFuncionalidade02()
}
```

Ã‰ possÃ­vel ter estruturas anÃ´nimas. Elas sÃ£o definidas quando apenas os tipos da struct sÃ£o definidos e os valores jÃ¡ sÃ£o inicializados. Go tambÃ©m permite utilizar composiÃ§Ã£o. Com as composiÃ§Ãµes, os elementos internos podem ser acessados pelos elementos externos. Portanto, funÃ§Ãµes associadas aos tipos internos, estarÃ£o acessÃ­veis para os elementos mais externos quando estes possuÃ­rem instÃ¢ncias internas suas. Este comportamento da ao Go um mecanismo similar ao de heranÃ§a e um mecanismo polimÃ³rfico a linguagem.

---

## 8. FunÃ§Ãµes

FunÃ§Ãµes sÃ£o uma forma de agrupar cÃ³digo. Isso terna o cÃ³digo desenvolvido mais simples de se reutilizar, compreender e manutenÃ­vel. Este comportamento tambÃ©m traz maior capacidade de abstraÃ§Ã£o para nosso cÃ³digo.

As funÃ§Ãµes possuem a seguinte estrutura bÃ¡sica: `func (receiver) nomeDaFuncao (parametrosESeusTipos) tipoDeRetornoDaFuncao {codigoDaFuncao}`. Um detalhe importante: definimos as funÃ§Ãµes descrevendo seus parÃ¢metros. Utilizamos uma funÃ§Ã£o informando seus argumentos.

IMPORTANTE: Tudo em Go Ã© passado por ***VALOR***. Uma funÃ§Ã£o pode ter nenhum, um ou quantos tipo de retorno for necessÃ¡rio.

Uma funÃ§Ã£o com o nÃºmero de parÃ¢metros variados Ã© possÃ­vel utilizando a notaÃ§Ã£o de um parÃ¢metro variÃ¡tico. Eles sÃ£o enviados como um slice para a funÃ§Ã£o. IMPORTANTE: um parÃ¢metro variÃ¡vel deve ser o Ãºltimo declaro na funÃ§Ã£o.

```go
package main

import "fmt"

// FunÃ§Ã£o com parÃ¢metros variÃ¡veis, pode ser qualquer quantidade
func adicionaValores(valores ...int) (int, int){
	total := 0
	for _, valor := range(valores){
		total += valor
	}
	return total, len(valores)
}

func main(){
	// Chamando funÃ§Ã£o adicionaValores
	fmt.Println(adicionaValores(1,2,3,4))
	fmt.Println(adicionaValores(1,2,3,4,5,6,7,8,9))
	// Enviando diversos valores, extraÃ­ndo todos eles
	valores := []int{3,4,5,6,7}
	fmt.Println(adicionaValores(valores...))
}
```

A extraÃ§Ã£o de todos os elementos de um array/slice, Ã© chamado de Unfurling. Todos os valores sÃ£o extraÃ­do e enviados para uma funÃ§Ã£o, por exemplo. IMPORTANTE: sem este operador, estamos enviando apenas um parÃ¢metro. Com ele, estamos enviando a quantidade de elementos que o slice possuir de parÃ¢metros.

O operador `defer` faz com que a chamada de uma funÃ§Ã£o nÃ£o seja resolvida no momento de sua realizaÃ§Ã£o. Desta forma, o sistema empilha sua chamada, resolve a funÃ§Ã£o atual e quando ela termina, executa a funÃ§Ã£o com `defer`.

```go
package main

import "fmt"

func comportamento_02(){
	defer ola1()
	ola2()
}

// Para compreender a utilizaÃ§Ã£o do defer
func ola1(){
	fmt.Println("Ola 1")
} 

func ola2(){
	fmt.Println("Ola 2")
} 

func main(){
	comportamento_02()
}
```

Em geral, quando fazemos a alocaÃ§Ã£o de algum recurso, como abrir uma conexÃ£o, um arquivo, utilizamos o `defer` para liberar este recurso.

Ã‰ possÃ­vel criar mÃ©todos em Go. Desta forma, as structs podem ter comportamentos associados a elas.

```go
package main

import "fmt"

// Criando mÃ©todos em Go
type Pessoa struct{
	nome string
	idade int
}

func (p Pessoa) DescrevePessoa(){
	fmt.Printf("Nome: %s\t Idade: %d\n", p.nome, p.idade)
}

func comportamento_03(){
	p1 := Pessoa{"Murilo", 36}
	p2 := Pessoa{"JÃ©ssica", 29}
	p1.DescrevePessoa()
	p2.DescrevePessoa()
}

func main(){
	comportamento_03()
}
```

Em Go, interfaces declaram um conjunto de assinaturas para mÃ©todos. Desta forma, quem implementa aquelas interfaces, devem possuir uma implementaÃ§Ã£o destes mÃ©todos. A capacidade polimÃ³rfica Ã© a habilidade de um tipo realizar um comportamento de um outro tipo.

Em Go, os valores podem possuir mais de um tipo. Isso permite que realizamos a implementaÃ§Ã£o do polimorfismo. Uma interface em Go Ã© implementada utilozando a palavra `interface`, na frente do seu nome. Desta forma, implementamos a sobrecarga de funÃ§Ãµes utilizando o polimorfismo. Qualquer estrutura que implementar os mÃ©todos da interface, tambÃ©m vai ser do tipo da interface. CUIDADO: Observar o cÃ³digo a seguir com bastante cuidado para compreender o conceito apresentado.

```go
package main

import "fmt"

// Criando mÃ©todos em Go
type Pessoa struct{
	nome string
	idade int
}

func (p Pessoa) DescrevePessoa(){
	fmt.Printf("Nome: %s\t Idade: %d\n", p.nome, p.idade)
}

type PessoaEspecial struct{
	pessoa Pessoa
	altura float32
}

// MÃ©todo da estrutura PessoaEspecial
func (p PessoaEspecial) DescrevePessoa(){
	fmt.Printf("Altura: %.2f\t", p.altura)
	p.pessoa.DescrevePessoa()
}

// Interface que traz uma assinatura. Todos que implementarem todos os seus mÃ©todos sÃ£o deste tipo tambÃ©m
type Human interface{
	DescrevePessoa()
}

// FunÃ§Ã£o para implementar o polimorfismo
func Descrever(h Human){
	h.DescrevePessoa()
}

func comportamento_04(){
	p1 := Pessoa{"Murilo", 36}
	p2 := PessoaEspecial{Pessoa{"JÃ©ssica", 29}, 1.49}
	Descrever(p1)
	Descrever(p2)
}

func main(){
	comportamento_04()
}
```


Existe uma interface chamada `Stringer`, que permite realizar o log de estruturas e elementos no cÃ³digo. Estruturas que possuem o mÃ©todo `String() string` implementa essa interface. NÃ£o precisa ser apenas uma estrutura, pode estar associado a uma variÃ¡vel, por exemplo.

```go
package main

import (
	"fmt"
	"strconv"
)

// Estudo da implementaÃ§Ã£o da interface Stringer()

type Usuario struct{
	nick string
	pass string
	nivel int
}

// Cria uma implementaÃ§Ã£o sobre um valor
type Teste int

func (u Usuario) String() string{
	return fmt.Sprintf("Usuario{nick:%s,pass:%s,elo:%d}", u.nick,u.pass,u.nivel)
}

func (t Teste) String() string{
	return fmt.Sprintf("Valor do Teste: %s", strconv.Itoa(int(t)))
}

func main(){
	user := Usuario{"Murilo","123456",5}
	fmt.Println(user)
	teste := Teste(10)
	fmt.Println(teste)
}
```


Em Go, existe um pacote padrÃ£o para lidar com logs da execuÃ§Ã£o do programa. Ele Ã© importado do pacote `"log"`. Ele possui as funÃ§Ãµes impressÃ£o na saÃ­da padrÃ£o como o "fmt". 

Lembrando, podemos implementar uma enumeraÃ§Ã£o no Go utilizando `iota`. Ela Ã© implementada como uma sequencia de inteiros. Go permite utilizar Wrapper Functions, que sÃ£o funÃ§Ãµes que encapsulam comportamentos. Desta forma, Ã© possÃ­vel direcionar um comportamento utilizando elas.

ATENÃ‡ÃƒO: Estudar o cÃ³digo a seguir com cuidado, tem vÃ¡rios detalhes importantes nele.

```go
package main

import (
	"fmt"
	"log"
)

// Define algumas estruturas para utilizar 
type User struct{
	name string
	acessLevel AcessLevels
}

// Cria uma enumeraÃ§Ã£o quanto ao nÃ­vel de acesso
type AcessLevels int
const (
	Visitante AcessLevels = iota
	Funcionario
	Administrador
	Dono
)
// Implementa a interface Stringer para utilizar a string
func (al AcessLevels) String() string{
	// Utiliza o operador spread para encontrar o equivalente ao nÃ­vel
	return [...]string{"Visitante", "Funcionario", "Administrador","Dono"}[al]
}

func (user User) String() string{
	return fmt.Sprintf("User{name:%s, acess: %s}", user.name, user.acessLevel)
}

// Wrapper Function para o comportamento de Log
// EstÃ¡ funÃ§Ã£o recebe elementos que implementam a interface
// Ela vai interceptar a chamada da funÃ§Ã£o log
func logInfo(s fmt.Stringer){
	log.Println("LOG REALIZADO NA APLICAÃ‡ÃƒO: ", s)
}

func main(){
	u1 := User{"Murilo", Dono}
	u2 := User{"Vegeta", Administrador}
	u3 := User{"Goku", Funcionario}

	log.Println(u1)

	users := []User{u1,u2,u3}
	for _, user := range(users){
		logInfo(user)
	}
}
```

## 9. Log e Escrita de Arquivos (Writter)

Primeiro vamos verificar como escrever um arquivo. Ele jÃ¡ estÃ¡ com algumas implementaÃ§Ãµes futuras, mas ele Ã© iniciado desta forma:

```go
package main

// Pacote para realizar a interface de writer
import (
	"io"
	"log"
	"os"
)

type Person struct{
	name string
}

// Interface de Writer, que recebe algo para ser escrito e retorna um erro se for preciso.
func (p Person) writeOut (w io.Writer) error{
	_, err := w.Write([]byte(p.name))
	return err
}

// FunÃ§Ã£o para verificar se um erro aconteceu
func temError(e error) bool{
	if e == nil{
		return false
	}
	log.Fatalf("Erro: %s", e)
	// Nunca chega aqui
	return true
}
func main(){
	// Cria um arquivo
	arquivo, err := os.Create("teste.txt")

	// Testa para verificar se ocorreu um erro na criaÃ§Ã£o do arquivo
	temError(err)

	// Adicionar o encerramento do arquivo
	defer arquivo.Close()

	// Cria um slice para enviar para o arquivo
	s := []byte("Ola Mundo!!")

	// Escreve os bytes no arquivo
	// AtenÃ§Ã£o ao detalhes, nesse caso, a variÃ¡vel `err` jÃ¡ existe
	_, err = arquivo.Write(s)

	temError(err)

}
```

Uma string Ã© um pouco diferente de um slice de bytes. Ã‰ possÃ­vel converter de um tipo para o outro. Em geral, os printer possuem um buffer. Isso Ã© implementado para que um conjunto temporÃ¡rio possa acomodar um conjunto de valores antes de sua utilizaÃ§Ã£o.


```go
package main

// Pacote para realizar a interface de writer
import (
	"bytes"
	"io"
	"log"
	"os"
	"fmt"
)

type Person struct{
	name string
}

// Interface de Writer, que recebe algo para ser escrito e retorna um erro se for preciso.
func (p Person) writeOut (w io.Writer) error{
	_, err := w.Write([]byte(p.name))
	return err
}

// FunÃ§Ã£o para verificar se um erro aconteceu
func temError(e error) bool{
	if e == nil{
		return false
	}
	log.Fatalf("Erro: %s", e)
	// Nunca chega aqui
	return true
}
func main(){
	// Cria um arquivo
	arquivo, err := os.Create("teste.txt")

	// Testa para verificar se ocorreu um erro na criaÃ§Ã£o do arquivo
	temError(err)

	// Adicionar o encerramento do arquivo
	defer arquivo.Close()

	// Cria um buffer de bytes
	var buffer bytes.Buffer

	// Cria uma pessoa
	p := Person{"Murilo"}

	// Escreve o conteÃºdo de pessoa no buffer e no arquivo
	// Arquivo
	p.writeOut(arquivo)
	// No endereÃ§o do buffer - trabalha com ponteiros a funÃ§Ã£o writeOut
	p.writeOut(&buffer)

	// Escreve o conteÃºdo do buffer na tela
	fmt.Println(buffer.String())
}
```

EstÃ¡ Ã© uma demonstraÃ§Ã£o do uso de interfaces do Go.

---

## 10. FunÃ§Ãµes AnÃ´nimas

Ã‰ um funÃ§Ã£o que nÃ£o possui um nome para invocaÃ§Ã£o, apenas um comportamento e sua chamada.

```go
package main

import "fmt"

// FunÃ§Ã£o tradicional
func mostrar(s string){
	fmt.Println(s)
}

func main(){
	// Chamando funÃ§Ã£o tradicional
	mostrar("Murilo")

	// Declarando e executando uma funÃ§Ã£o anÃ´nima
	func(s string){
		fmt.Println(s)
	}("Murilo")
}
```

FunÃ§Ãµes sÃ£o cidadÃ£os de primeira classe em Go, o que significa que eles podem ser considerados como um tipo. Portanto, podem ser atribuÃ­dos para variÃ¡veis. Elas tambÃ©m podem ser enviadas como parÃ¢metros em outras funÃ§Ãµes.

```go
package main

import "fmt"

// FunÃ§Ã£o tradicional
func mostrar(s string){
	fmt.Println(s)
}

func main(){
	// Chamando funÃ§Ã£o tradicional
	mostrar("Murilo")

	// Declarando e executando uma funÃ§Ã£o anÃ´nima
	func(s string){
		fmt.Println(s)
	}("Murilo")

	// AtribuÃ­ndo uma funÃ§Ã£o a uma variÃ¡vel
	x := mostrar

	// Chamando a funÃ§Ã£o pela variÃ¡vel
	x("Teste")

	// Atribuindo uma funÃ§Ã£o anÃ´nima
	y := func(x,y int) int {
		return x+y
	}

	fmt.Println(y(3,4))
}
```

Quando retornar uma funÃ§Ã£o, devolver apenas o nome da funÃ§Ã£o, assim seu endereÃ§o serÃ¡ atribuÃ­do ao valor que invocou a funÃ§Ã£o que a devolveu.


Em geral, funÃ§Ãµes enviadas como argumentos, estÃ£o enviando um `callback` para essa funÃ§Ã£o. Em geral, permite que a funÃ§Ã£o que recebeu esse argumento a execute quando for preciso.

Quando enviando uma funÃ§Ã£o como callback, enviamos a assinatura da funÃ§Ã£o no parÃ¢metro.

```go
package main

import "fmt"

// Definindo uma fun;cÃ£o
func operacao(a int, b int, c func(int, int) int) int{
	return c(a,b)
}


func somar(a int, b int) int {
	return a+b
}

func subtrair(a int, b int) int {
	return a-b
}

func multiplicar(a int, b int) int {
	return a*b
}

func dividir(a int, b int) int {
	return a/b
}

func main(){
	// Cria uma slice com as funÃ§Ãµes
// AtenÃ§Ã£o: o tipo func() deve coincidir com as assinaturas das funÃ§oes utilizadas.
	funcoes := []func(int,int)int {somar, subtrair, dividir, multiplicar,}

	a := 10
	b := 5

	// Chamndo as diversas operaÃ§Ãµes
	for _, funcao := range(funcoes){
		fmt.Println(operacao(a,b,funcao))
	}
}
```

Closures sÃ£o funÃ§Ãµes dentro de funÃ§Ãµes. Elas sÃ£o chamadas a cada chamada e execuÃ§Ã£o da funÃ§Ã£o mais externa. Ele mantÃ©m, no caso do exemplo abaixo, o valor da variÃ¡vel interna do Closure.

```go
package main

import "fmt"

func TesteClosure() func() int{
	x := 0
	return func ()int{ 
		x++
		return x
	}
}

func main(){
	// AtribuÃ­ o closure para uma variÃ¡vel
	teste_closure := TesteClosure()

	fmt.Println(teste_closure())
	fmt.Println(teste_closure())
	fmt.Println(teste_closure())
}

// SaÃ­da: 1, 2, 3
```

### IMPORTANTE: Wrapper Functions

Retomando: Wrapper Functions permitem trazer mais uma camada de abstraÃ§Ã£o para outra funÃ§Ã£o. Ela traz outras funcionalidades para uma funÃ§Ã£o que jÃ¡ estÃ¡ implementada.

***Importante:*** Quando utilizamos `defer` nas funÃ§Ãµes, elas sÃ£o empilhadas em uma estrutura LIFO, portanto, a Ãºltima funÃ§Ã£o deferida, serÃ¡ a primeira resolvida.



---


## 11. ImplementaÃ§Ãµes de Testes com Go

Os arquivos de teste em Go precisam seguir algumas convenÃ§Ãµes de nome para ser utilizados. Os arquivos de teste ficam no mesmo pacote, mas importam o mÃ³dulo `"testing"`. Quando vamos testar uma funÃ§Ã£o, devemos criar o teste dela com outra funÃ§Ã£o com o nome `TestNomeFuncao(t * testing.T)`.

Arquivo `main.go`:

```go
package main

func Somar(valores ...int) int {
	total := 0
	for _,valor := range(valores){
		total += valor
	}
	return total
}

func main(){

}
```

Arquivo `main_test.go`:

```go
package main

import "testing"

func TestSomar(t *testing.T){
	// Primeiro Teste
	valores := []int{4,6,7,8}
	total := Somar(valores...)
	if total != 25 {
		t.Errorf("Somatoria incorreta, esperado %d, recebido %d", 25, total)
	}

	// Segundo Teste
	total = Somar(3,4,5)
	if total != 12{
		t.Errorf("Somatoria incorreta, esperado %d, recebido %d", 12, total)
	}
}
```

Para executar o teste, rodar o comando: `go test`.
ObservaÃ§Ãµes importantes antes de seguir:
- O projeto deve estar em um mÃ³dulo para rodar os testes. Ã‰ importante que esse mÃ³dulo nÃ£o tenho o nome de `main`, caso contrÃ¡rio nÃ£o serÃ¡ possÃ­vel importar o arquivo main.go para rodar os testes.
- Para iniciar o mÃ³dulo: `go mod init nomeDoModulo`
- Para rodar os testes: `go test`, no diretÃ³rio com os arquivos de teste, senÃ£o dar o endereÃ§o do diretÃ³rio.

Para documentar um programa, devemos apenas colocar os comentÃ¡rios antes da funÃ§Ã£o que vamos documentar. Iniciamos nossa documentaÃ§Ã£o com o nome da FunÃ§Ã£o/elemento que vamos documentar. A documentaÃ§Ã£o completa pode ser gerada utilizando a ferramenta `go doc`.

## ATENÃ‡ÃƒO: Precisa ser ajustado, nÃ£o estÃ¡ implementado corretamente.


---

## 12. Ponteiros

Ponteiros permitem trabalhar com posiÃ§Ãµes de memÃ³ria em GoLang. O operador `&` nos da o endereÃ§o de uma variÃ¡vel. Os ponteiros em Go sÃ£o muito semelhantes aos ponteiros em C. Lembrar que um ponteiro Ã© um endereÃ§o de memÃ³ria tambÃ©m.

```go
package main

import "fmt"


// Estudo do uso de ponteiros
func main(){
	x:=42
	fmt.Println(x)
	fmt.Println(&x)
	fmt.Printf("%v\t%T", &x,&x)
}
```

A saÃ­da para execuÃ§Ã£o deste cÃ³digo:
```sh
42
0xc00000a0d8
0xc00000a0d8    *int
```

Um \* na frente de um tipo indica que Ã© um ponteiro. No caso da saÃ­da produzida acima, estamos falando de um ponteiro para um nÃºmero inteiro. O operador \* Ã© utilizado para derreferenciar uma posiÃ§Ã£o de memÃ³ria. Ele acessa o que estÃ¡ dentro do conteÃºdo da variÃ¡vel. 

```go
package main

import "fmt"


// Estudo do uso de ponteiros
func main(){
	x:=42
	// Cria um ponteiro para x
	y := &x

	// Mostra o valor de x
	fmt.Println(x)
	// Mostra o endereÃ§o de x, que Ã© o valor armazenado em y
	fmt.Println(y)
	// Mostra o valor de x, por derreferenciar y
	fmt.Println(*y)
	// Mostra o endereÃ§o de x
	fmt.Println(&x)
	// Mostra o endereÃ§o de y
	fmt.Println(&y)
}
```

A saÃ­da do programa:

```sh
42
0xc00000a0d8
42
0xc00000a0d8
0xc00004c050
```

Podemos enviar endereÃ§os para funÃ§Ãµes, assim qualquer mudanÃ§a realizada nela vai alterar os valores do ponto que fez a chamada.

```go
package main

import "fmt"

// FunÃ§Ã£o que recebe por valor
func Dobro(x int){
	x = 2*x
}

// FunÃ§Ã£o que recebe por referncia
func DobroRef(x *int){
	*x = 2 * (*x)
}
// Estudo do uso de ponteiros
func main(){
	x:=42
	
	// Chama por valor
	Dobro(x)
	fmt.Println(x)
	// Chama por referencia
	DobroRef(&x)
	fmt.Println(x)
}
```

IMPORTANTE: Sempre que possÃ­vel, trabalhar com passagem por valor, isso simplifica a utilizaÃ§Ã£o e depuraÃ§Ã£o do funcionamento do programa. Pois torna mais claro os pontos que estÃ£o modificando o funcionamento do programa.

- ***Value Semantics:*** Passagem por valor. Ã‰ o modo padrÃ£o de trabalho do GoLang.
- ***Pointer Semantics:*** Passagem de valor por referÃªncia. A funÃ§Ã£o pode modificar o elemento dentro da funÃ§Ã£o. Quando utilizamos grande quantidade de dados armazenados, pode ser uma abordagem interessante.

A funÃ§Ã£o `init()` Ã© executada antes da funÃ§Ã£o `main()`. Em geral Ã© utilizada para inicializar algum parÃ¢metro ou elemento do nosso programa.

---

## 13. Tipos GenÃ©ricos

SÃ£o tipos de dados que podem assumir um conjunto de valores diferentes. Desta forma, quando diferentes tipos puderem ser aceitos em uma funÃ§Ã£o, podemos utilizar este comportamento.

```go
package main

import "fmt"

// Utilizando funÃ§Ãµes que nÃ£o genÃ©ricas
func SomaI(a,b int) int{
	return a+b
}

func SomaF(a,b float64) float64{
	return a+b
}

// Utilizando tipos genÃ©ricos
func Soma [T int | float64](a,b T) T{
	return a+b
}

func main(){
	i1 := 10
	i2 := 20
	f1:=32.0
	f2 := 10.0
	fmt.Println("Soma Inteiros:", SomaI(i1,i2))
	fmt.Println("Soma Reais:", SomaF(f1,f2))
	fmt.Println("Soma Inteiros:", Soma(i1,i2))
	fmt.Println("Soma Reais:", Soma(f1,f2))
}
```

Este mesmo comportamento pode ser implementado utilizando interfaces.

```go
package main

import "fmt"

// Utilizando funÃ§Ãµes que nÃ£o genÃ©ricas
func SomaI(a,b int) int{
	return a+b
}

func SomaF(a,b float64) float64{
	return a+b
}

// Utilizando tipos genÃ©ricos
type MeusNumeros interface{
	int | float64
}

func Soma [T MeusNumeros](a,b T) T{
	return a+b
}

func main(){
	i1 := 10
	i2 := 20
	f1:=32.0
	f2 := 10.0
	fmt.Println("Soma Inteiros:", SomaI(i1,i2))
	fmt.Println("Soma Reais:", SomaF(f1,f2))
	fmt.Println("Soma Inteiros:", Soma(i1,i2))
	fmt.Println("Soma Reais:", Soma(f1,f2))
}
```

Quando utilizamos o operador `~` na frente de um tipo, estamos indicando que qualquer alias para aquele tipo serÃ£o consideradas como o tipo bÃ¡sico na utilizaÃ§Ã£o do tipo genÃ©rico.

---

## 14. AplicaÃ§Ãµes

O gerenciamento de erros em Go Ã© realizado, em geral, logo depois que um erro pode acontecer. Em Go nÃ£o procuramos exceÃ§Ãµes, mas sim, verificamos se algum erro ocorreu no momento que ele poderia acontecer (retorno de uma funÃ§Ã£o por exemplo).

IMPORTANTE: Uma string Ã© um conjunto de bytes. Essa definiÃ§Ã£o Ã© muito importante, pois diversas funÃ§Ãµes utilizam um slice de bytes `[]bytes` para funcionar.

Existe, em GoLang, duas formas de codificar algo em JSON, referentes a forma como Ã© realizado o processo de mapear os tipos de dados de JSON para os primitivos de Go:
- ***Marshaling:*** Processo de transformar uma estrutura do Go (ou mapa com chaves como Strings) para JSON. IMPORTANTE: Os campos devem ser exportados (iniciar com letra maiuscula)
- ***Unmarshaling:*** Processo de trazer dados em JSON (slice de `[]bytes`) para uma estrutura Go.

Para maiores informaÃ§Ãµes, consultar a documentaÃ§Ã£o aqui: https://go.dev/blog/json

```go
package main

import (
	"encoding/json"
	"fmt"
	"log"
)

// Criando as estruturas que serÃ£o utilizadas

type Person struct{
	First string
	Last string
	Age int
}

func (p Person) String() string{
	return fmt.Sprintf("Person{\"first\":%s, \"last\":%s, \"age\":%d}", p.First, p.Last, p.Age)
}

func main(){
	p1 := Person{"Murilo", "Carvalho", 36}
	p2 := Person{"Vegeta", "Prince", 44}
	p3 := Person{"Kakaroto", "Goku", 42}

	// Criando um JSON para enviar
	people := []Person{p1,p2,p3}

	byteSlice,err := json.Marshal(people)

	// Verifica se aconteceu algum erro no processo de codificaÃ§Ã£o
	if err != nil {
		log.Fatalf("Erro ocorreu: %v", err)
	}

	// Converte o byte slice para uma string
	fmt.Println(string(byteSlice))
}
```

Para verificar o processo de retirar os dados e colocar dentro das estruturas de dados:

```go
package main

import (
	"encoding/json"
	"fmt"
	"log"
)

// Criando as estruturas que serÃ£o utilizadas

type Person struct{
	First string
	Last string
	Age int
}

func (p Person) String() string{
	return fmt.Sprintf("Person{\"first\":%s, \"last\":%s, \"age\":%d}", p.First, p.Last, p.Age)
}

func main(){
	p1 := Person{"Murilo", "Carvalho", 36}
	p2 := Person{"Vegeta", "Prince", 44}
	p3 := Person{"Kakaroto", "Goku", 42}

	// Criando um JSON para enviar
	people := []Person{p1,p2,p3}

	byteSlice,err := json.Marshal(people)

	// Verifica se aconteceu algum erro no processo de codificaÃ§Ã£o
	if err != nil {
		log.Fatalf("Erro ocorreu: %v", err)
	}

	// Converte o byte slice para uma string
	fmt.Println(string(byteSlice))

	// Convertendo agora um array de objetos
	// O `` Ã© utilizado para string multilinhas
	s := `[{"First":"Murilo","Last":"Carvalho","Age":36},{"First":"Vegeta","Last":"Price","Age":44},{"First":"Kakaroto","Last":"Goku","Age":42}]`

	bs := []byte(s)

	// Cria um conjunto de dados para armazenar a resposta
	var saida []Person
	
	err = json.Unmarshal(bs, &saida)

	// Verifica se algum erro aconteceu
	if err != nil {
		log.Fatalf("Erro ocorreu: %v", err)
	}

	fmt.Println(saida)

	// Passando por cada um dos objetos
	for i, p := range(saida){
		fmt.Println("Linha atual:", i)
		fmt.Println("ConteÃºdo:", p)
		fmt.Println("Nome:", p.First)
	}

}
```

---

O pacote `sort` traz algumas ferramentas que podem ser utilizadas para ordenar conjuntos de dados primitivos e definidos pelo usuÃ¡rio. Mais informaÃ§Ãµes na documentaÃ§Ã£o do pacote: https://pkg.go.dev/sort#pkg-overview. Verificar o pacote `bcrypt` para criptografia de projetos.

---

## 15. Paralelismo e ConcorrÃªncia

Go aproveita mÃºltiplos cores do processador. Paralelismo acontece quando o cÃ³digo pode ser executado em nÃºcleos diferentes, sendo executados ao mesmo tempo. ConcorrÃªncia Ã© um padrÃ£o de desenvolvimento. Quando existe recursos de hardware, cÃ³digo concorrente pode ser executado em paralelo. Verificar a palestra de Rob Pike (https://www.youtube.com/watch?v=oV9rvDllKEg).

<iframe width="560" height="315" src="https://www.youtube.com/embed/oV9rvDllKEg?si=yiTbxmIYt4nzxLwX" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

Para iniciar a compreensÃ£o deste conceito, vamos verificar este programa:

```go
package main

import "fmt"

func foo(){
	for i := 0; i < 10; i++ {
		fmt.Println("Foo:", i)
	}
}

func bar(){
	for i := 0; i < 10; i++ {
		fmt.Println("Bar:", i)
	}
}

func main(){
	foo()
	bar()
}
```


Ele vai produzir a saÃ­da:

```sh
Foo: 0
Foo: 1
Foo: 2
Foo: 3
Foo: 4
Foo: 5
Foo: 6
Foo: 7
Foo: 8
Foo: 9
Bar: 0
Bar: 1
Bar: 2
Bar: 3
Bar: 4
Bar: 5
Bar: 6
Bar: 7
Bar: 8
Bar: 9
```

Como esperado, uma vez que a funÃ§Ã£o `foo()` foi invocada antes da funÃ§Ã£o `bar()`. Ã‰ possÃ­vel utilizando o pacote `runtime` medir algumas das caracterÃ­sticas do sistema que roda nosso programa:

```go
// FunÃ§Ã£o para determinar a capacidade do nosso sistema operacional
func MedeAi(){
	fmt.Println("OS:", runtime.GOOS)
	fmt.Println("ARCH:", runtime.GOARCH)
	fmt.Println("CPUs:", runtime.NumCPU())
	fmt.Println("Goroutines:", runtime.NumGoroutine())
}
```

Quando desejamos utilizar uma Gorotine, que vai executar uma funÃ§Ã£o de forma concorrente, utilizamos o operador `go` antes da chamada da funÃ§Ã£o.

```go
package main

import (
	"fmt"
	"runtime"
)

func foo(){
	for i := 0; i < 10; i++ {
		fmt.Println("Foo:", i)
	}
}

func bar(){
	for i := 0; i < 10; i++ {
		fmt.Println("Bar:", i)
	}
}

// FunÃ§Ã£o para determinar a capacidade do nosso sistema operacional
func MedeAi(){
	fmt.Println("OS:", runtime.GOOS)
	fmt.Println("ARCH:", runtime.GOARCH)
	fmt.Println("CPUs:", runtime.NumCPU())
	fmt.Println("Goroutines:", runtime.NumGoroutine())
}

func main(){
	MedeAi()
	go foo()
	go bar()
	MedeAi()
}
```

A saÃ­da do nosso programa serÃ¡:

```sh
OS: windows
ARCH: amd64
CPUs: 6
Goroutines: 1
OS: windows
ARCH: amd64
CPUs: 6
Goroutines: 3
```

Repare que as saÃ­das das funÃ§Ãµes nÃ£o estÃ£o no nosso programa principal. Quando a funÃ§Ã£o `main()` termina sua execuÃ§Ã£o, todo o programa Ã© encerrado. Existem algumas formas de sincronizar a execuÃ§Ã£o das Gorotines.
